<?php

/**
 * @file
 * Contains sp_retrieve.module.
 */

use Drupal\Core\Entity\EntityInterface;
use Drupal\sp_create\PlanYearInfo;
use Drupal\Core\Cache\Cache;
use Drupal\taxonomy\Entity\Term;
use Drupal\node\Entity\Node;
use Drupal\Core\Form\FormStateInterface;
use Drupal\group\Entity\Group;

/**
 * Implements hook_entity_insert().
 */
function sp_retrieve_entity_insert(EntityInterface $entity) {
  sp_retrieve_invalidate_plan_content_cache($entity, 'insert');
}

/**
 * Implements hook_entity_update().
 */
function sp_retrieve_entity_update(EntityInterface $entity) {
  sp_retrieve_invalidate_plan_content_cache($entity, 'update');
}

/**
 * Implements hook_entity_delete().
 */
function sp_retrieve_entity_delete(EntityInterface $entity) {
  sp_retrieve_invalidate_plan_content_cache($entity, 'delete');
}

/**
 * Invalidate the caches used to retrieve state plan content.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   The entity that triggered the cache clear.
 * @param string $op
 *   Either insert, update, or delete.
 *
 * @throws \Drupal\Component\Plugin\Exception\InvalidPluginDefinitionException
 * @throws \Drupal\Component\Plugin\Exception\PluginNotFoundException
 */
function sp_retrieve_invalidate_plan_content_cache(EntityInterface $entity, $op) {
  // Caches whether there are state plan * nodes that haven't been created yet.
  $clear_missing_content_cache = FALSE;
  // Caches whether there are answers that can be copied.
  $clear_copy_answer_cache = FALSE;
  /** @var \Drupal\sp_retrieve\NodeService $node_service */
  $node_service = \Drupal::getContainer()
    ->get('sp_retrieve.node');
  // Only clear cache based on section terms or state plan year nodes.
  if (
    ($entity instanceof Term && PlanYearInfo::getPlanYearIdAndSectionIdFromVid($entity->bundle())) ||
    ($entity instanceof Node && in_array($entity->bundle(), PlanYearInfo::getSpyNodeBundles())) ||
    $entity instanceof Group
  ) {
    // Only section terms being updated can affect the missingness of a node
    // content, as they could have changed what type of node is referenced.
    // Any state plan year node type being inserted or deleted can change
    // the missingness of content. The only nodes that are updated, state
    // plan year content, do nothing about missingness.
    // If any group is inserted, updated, or deleted, that will result in
    // missing plan content.
    if ($entity instanceof Group || (in_array($op, ['insert', 'delete'], TRUE)) || ($op === 'update' && $entity instanceof Term)) {
      $clear_missing_content_cache = TRUE;
    }
    // Anytime a state plan year answer node is updated, inserted, or deleted
    // clear the copy cache answer cache. This could happen from a state plan
    // year being modified or any state answer answering a question.
    // ** IMPORTANT **
    // Updating a term could cause a state plan year answer to change
    // but only after it has been deleted and re-created. Don't allow admins
    // to copy answers if there are outstanding state plan year answer orphans
    // to be create / removed. This could be fine tuned even further to not
    // clear cache if the state plan year content was being updated and not
    // changing value state. For example, empty -> empty, not empty -> not
    // empty will not change if the content can be copied or not.
    // If any group is inserted, updated, or deleted, that will result in the
    // copy answer content.
    if ($entity instanceof Group || in_array($entity->bundle(), PlanYearInfo::getSpyaNodeBundles())) {
      $clear_copy_answer_cache = TRUE;
    }
  }

  if (TRUE === $clear_missing_content_cache) {
    // Use the entity to determine if it is specific to a plan year.
    $plan_year_id = PlanYearInfo::getPlanYearIdFromEntity($entity);
    if (FALSE !== $plan_year_id) {
      // All plan years caches (getOrphansStatePlanYearAnswers is for 'all' plan
      // years).
      Cache::invalidateTags($node_service->getMissingContentCacheTags());
      Cache::invalidateTags($node_service->getMissingContentCacheTags($plan_year_id));
    }
    else {
      // Groups are not specific to a single year, for example.
      Cache::invalidateTags($node_service->getMissingContentAllCacheTags());
    }
  }
  if (TRUE === $clear_copy_answer_cache) {
    // Use the entity to determine if it is specific to a state plan year node.
    $state_plan_year_nid = PlanYearInfo::getStatePlanYearNidFromEntity($entity);
    if (FALSE !== $state_plan_year_nid) {
      Cache::invalidateTags($node_service->getCopyAnswersCacheTags($state_plan_year_nid));
      // This will clear the cache of state plan years that this state plan year
      // is a source of, ie it's getting copied to this year, not that it's
      // copying from.
      foreach ($node_service->getStatePlanYearsCopyingTo($state_plan_year_nid) as $state_plan_year_nid_to) {
        Cache::invalidateTags($node_service->getCopyAnswersCacheTags($state_plan_year_nid_to));
      }
    }
    else {
      // Groups are not specific to a single year, for example.
      Cache::invalidateTags($node_service->getCopyAnswersAllCacheTags());
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function sp_retrieve_form_views_exposed_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  // If not the view we are looking, move on.
  switch ($form['#id']) {
    case 'views-exposed-form-manage-plans-moderated-content':
      _sp_retrieve_manage_plans_form_alter($form, $form_state);
      break;

    case 'views-exposed-form-all-plans-6-page-1':
      _sp_retrieve_all_plans_form_alter($form, $form_state);
      break;

  }

}

/**
 * Alter the all plans views exposed filters form.
 *
 * @param array $form
 *   The form.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The form state object.
 *
 * @all_plans
 *
 * @throws \Drupal\Component\Plugin\Exception\InvalidPluginDefinitionException
 * @throws \Drupal\Component\Plugin\Exception\PluginNotFoundException
 */
function _sp_retrieve_all_plans_form_alter(array &$form, FormStateInterface $form_state) {
  // Get all state plans year node labels.
  $spzy_labels = _sp_retrieve_get_state_plans_year_options();
  // On initial load, set latest year.
  $input = $form_state->getUserInput();
  if (empty($input['plans_year']) && !empty($spzy_labels)) {
    $input['plans_year'] = key($spzy_labels);
    $form_state->setUserInput($input);
  }
  _sp_retrieve_textfield_to_select($form['plans_year'], $spzy_labels, t('Plan Year'));

  // @TODO: This is the label of the workflow ID state_plan_year, load it and
  // get the label instead.
  $state_plan_year_workflow_label = 'State Plan Year';
  // The easiest way to get only the state plan year moderation state in here
  // is to do 'All' in the view, then remove the rest. Otherwise the view has
  // to be updated every time a new moderation state is added.
  $form['plan_status']['#options'] = $form['plan_status']['#options'][$state_plan_year_workflow_label];
  $form['plan_status']['#options'] = array_merge(['All' => t('View All')], $form['plan_status']['#options']);

  $form['gid']['#autocomplete_route_name'] = 'sp_display.state_label.autocomplete';
  $form['#validate'][] = '_sp_retrieve_all_plans_form_validate';
}

/**
 * Validate the all plans views exposed filters form.
 *
 * @param array $form
 *   The form.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The form state object.
 *
 * @all_plans
 */
function _sp_retrieve_all_plans_form_validate(array $form, FormStateInterface $form_state) {
  if ($form_state->hasValue('gid')) {
    // The value is submitted like: Illinois (33), where 33 is the group ID.
    $group_with_state_label = $form_state->getValue('gid');
    // Get the (33) portion.
    if (preg_match('/\([0-9]*\)$/', $group_with_state_label, $matches)) {
      // Remove the parens.
      $gid = preg_replace('/[^0-9]/', '', current($matches));
      // Set the value to search for as the actual group ID.
      $form_state->setValue('gid', $gid);
    }
  }
}

/**
 * Alter the manage plans views exposed filters form.
 *
 * @param array $form
 *   The form.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The form state object.
 *
 * @throws \Drupal\Component\Plugin\Exception\InvalidPluginDefinitionException
 * @throws \Drupal\Component\Plugin\Exception\PluginNotFoundException
 */
function _sp_retrieve_manage_plans_form_alter(array &$form, FormStateInterface $form_state) {
  $field = 'plan-year';
  // Get all state plans year node labels.
  $spzy_labels = _sp_retrieve_get_state_plans_year_options();
  // On initial load, set latest year.
  $input = $form_state->getUserInput();
  if (empty($input[$field]) && !empty($spzy_labels)) {
    $input[$field] = key($spzy_labels);
    $form_state->setUserInput($input);
  }
  _sp_retrieve_textfield_to_select($form['plan-year'], $spzy_labels, t('Plan Year'));
}

/**
 * Retrieve all state plan years labels.
 *
 * @return array
 *   All state plan years labels.
 *
 * @throws \Drupal\Component\Plugin\Exception\InvalidPluginDefinitionException
 * @throws \Drupal\Component\Plugin\Exception\PluginNotFoundException
 */
function _sp_retrieve_get_state_plans_year_options() {
  /** @var \Drupal\sp_retrieve\CustomEntitiesService $custom_entities */
  $custom_entities = Drupal::getContainer()->get('sp_retrieve.custom_entities');
  return $custom_entities->labels('node', PlanYearInfo::SPZY_BUNDLE, 'type');
}

/**
 * Turn a textfield into a select.
 *
 * @param array $form_element
 *   The form element to turn into a select.
 * @param array $options
 *   The select options.
 * @param string|int $default_option
 *   The default value if there is no options.
 */
function _sp_retrieve_textfield_to_select(array &$form_element, array $options, $default_option) {
  // Change the text input to a select.
  $form_element['#type'] = 'select';
  $form_element['#multiple'] = FALSE;

  // Specify the empty option for our select list.
  if (empty($options)) {
    $form_element['#empty_option'] = $default_option;
  }

  // Add the $options from above to our select list.
  $form_element['#options'] = $options;
  unset($form_element['#size']);
}
