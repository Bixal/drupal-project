<?php

/**
 * @file
 * Contains sp_retrieve.module.
 */

use Drupal\Core\Entity\EntityInterface;
use Drupal\sp_create\PlanYearInfo;
use Drupal\Core\Cache\Cache;
use Drupal\taxonomy\Entity\Term;
use Drupal\node\Entity\Node;
use Drupal\Core\Form\FormStateInterface;
use Drupal\group\Entity\Group;

/**
 * Implements hook_entity_insert().
 */
function sp_retrieve_entity_insert(EntityInterface $entity) {
  sp_retrieve_invalidate_plan_content_cache($entity, 'insert');
}

/**
 * Implements hook_entity_update().
 */
function sp_retrieve_entity_update(EntityInterface $entity) {
  sp_retrieve_invalidate_plan_content_cache($entity, 'update');
}

/**
 * Implements hook_entity_delete().
 */
function sp_retrieve_entity_delete(EntityInterface $entity) {
  sp_retrieve_invalidate_plan_content_cache($entity, 'delete');
}

/**
 * Invalidate the caches used to retrieve state plan content.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   The entity that triggered the cache clear.
 * @param string $op
 *   Either insert, update, or delete.
 *
 * @throws \Drupal\Component\Plugin\Exception\InvalidPluginDefinitionException
 * @throws \Drupal\Component\Plugin\Exception\PluginNotFoundException
 */
function sp_retrieve_invalidate_plan_content_cache(EntityInterface $entity, $op) {
  // Caches whether there are state plan * nodes that haven't been created yet.
  $clear_missing_content_cache = FALSE;
  // Caches whether there are answers that can be copied.
  $clear_copy_answer_cache = FALSE;
  /** @var \Drupal\sp_retrieve\NodeService $node_service */
  $node_service = \Drupal::getContainer()
    ->get('sp_retrieve.node');
  // Only clear cache based on section terms or state plan year nodes.
  if (
    ($entity instanceof Term && PlanYearInfo::getPlanYearIdAndSectionIdFromVid($entity->bundle())) ||
    ($entity instanceof Node && in_array($entity->bundle(), PlanYearInfo::getSpyNodeBundles())) ||
    $entity instanceof Group
  ) {
    // Only section terms being updated can affect the missingness of a node
    // content, as they could have changed what type of node is referenced.
    // Any state plan year node type being inserted or deleted can change
    // the missingness of content. The only nodes that are updated, state
    // plan year content, do nothing about missingness.
    // If any group is inserted, updated, or deleted, that will result in
    // missing plan content.
    if ($entity instanceof Group || (in_array($op, ['insert', 'delete'], TRUE)) || ($op === 'update' && $entity instanceof Term)) {
      $clear_missing_content_cache = TRUE;
    }
    // Anytime a state plan year answer node is updated, inserted, or deleted
    // clear the copy cache answer cache. This could happen from a state plan
    // year being modified or any state answer answering a question.
    // ** IMPORTANT **
    // Updating a term could cause a state plan year answer to change
    // but only after it has been deleted and re-created. Don't allow admins
    // to copy answers if there are outstanding state plan year answer orphans
    // to be create / removed. This could be fine tuned even further to not
    // clear cache if the state plan year content was being updated and not
    // changing value state. For example, empty -> empty, not empty -> not
    // empty will not change if the content can be copied or not.
    // If any group is inserted, updated, or deleted, that will result in the
    // copy answer content.
    if ($entity instanceof Group || in_array($entity->bundle(), PlanYearInfo::getSpyaNodeBundles())) {
      $clear_copy_answer_cache = TRUE;
    }
  }

  if (TRUE === $clear_missing_content_cache) {
    // Use the entity to determine if it is specific to a plan year.
    $plan_year_id = PlanYearInfo::getPlanYearIdFromEntity($entity);
    if (FALSE !== $plan_year_id) {
      // All plan years caches (getOrphansStatePlanYearAnswers is for 'all' plan
      // years).
      Cache::invalidateTags($node_service->getMissingContentCacheTags());
      Cache::invalidateTags($node_service->getMissingContentCacheTags($plan_year_id));
    }
    else {
      // Groups are not specific to a single year, for example.
      Cache::invalidateTags($node_service->getMissingContentAllCacheTags());
    }
  }
  if (TRUE === $clear_copy_answer_cache) {
    // Use the entity to determine if it is specific to a state plan year node.
    $state_plan_year_nid = PlanYearInfo::getStatePlanYearNidFromEntity($entity);
    if (FALSE !== $state_plan_year_nid) {
      Cache::invalidateTags($node_service->getCopyAnswersCacheTags($state_plan_year_nid));
      // This will clear the cache of state plan years that this state plan year
      // is a source of, ie it's getting copied to this year, not that it's
      // copying from.
      foreach ($node_service->getStatePlanYearsCopyingTo($state_plan_year_nid) as $state_plan_year_nid_to) {
        Cache::invalidateTags($node_service->getCopyAnswersCacheTags($state_plan_year_nid_to));
      }
    }
    else {
      // Groups are not specific to a single year, for example.
      Cache::invalidateTags($node_service->getCopyAnswersAllCacheTags());
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function sp_retrieve_form_views_exposed_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  // If not the view we are looking, move on.
  if ($form['#id'] != 'views-exposed-form-manage-plans-moderated-content') {
    return FALSE;
  }

  // Get all state plans year nodes.
  /** @var \Drupal\node\NodeStorage $storage */
  $storage = Drupal::getContainer()->get('entity_type.manager')->getStorage('node');
  $nids = $storage->getQuery()->condition('type', PlanYearInfo::SPZY_BUNDLE)
    ->sort('title', 'DESC')
    ->accessCheck(FALSE)
    ->execute();

  /** @var \Drupal\Core\Messenger\Messenger $messenger */
  $messenger = Drupal::getContainer()->get('messenger');
  // If there are no nodes, move on.
  if (!$nids) {
    $messenger->addError('There are no state plan years created yet.');
    return FALSE;
  }

  // On initial load, set latest year.
  $input = $form_state->getUserInput();
  if (empty($input['plan-year'])) {
    $input['plan-year'] = current($nids);
    $form_state->setUserInput($input);
  }

  // Start building out the options for our select list.
  $options = [];
  $nodes = $storage->loadMultiple($nids);

  // Push titles into select list.
  /** @var \Drupal\node\Entity\Node $node */
  foreach ($nodes as $node) {
    $options[$node->id()] = $node->getTitle();
  }
  // Change the text input to a select.
  $field = 'plan-year';
  $form[$field]['#type'] = 'select';
  $form[$field]['#default_value'];
  $form[$field]['#multiple'] = FALSE;

  // Specify the empty option for our select list.
  $form[$field]['#empty_option'] = t('Plan Year');

  // Add the $options from above to our select list.
  $form[$field]['#options'] = $options;
  unset($form[$field]['#size']);
}
